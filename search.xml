<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F06%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[异步DOM更新]]></title>
    <url>%2F2018%2F06%2F18%2Fvue-%E5%BC%82%E6%AD%A5DOM%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[造成的现象123456789101112131415161718192021222324252627282930&lt;div id="app"&gt; &lt;h1&gt; &#123;&#123; num &#125;&#125; &lt;/h1&gt; &lt;button @click="fn"&gt; 按钮 &lt;/button&gt;&lt;/div&gt;data: &#123; num: 1 &#125;,methods: &#123; fn() &#123; // 点击按钮获取DOM中的值 // 此处还没有点击,所以获取的是 1 console.log(document.querySelector('h1').innerText) // -&gt; 1 this.num++ // 每次点击让num+1 // **如果此处获取,获取的还是1,因为DOM更新是异步的,没有更新这么快** console.log(document.querySelector('h1').innerText) // -&gt; 1 // 若是给个延迟,可以获取到2 setTimeout(() =&gt; &#123; console.log(document.querySelector('h1').innerText) // -&gt; 2 &#125;, 1000) &#125; &#125; 解决的方案 1.如上,给个延迟,但有缺点,不能确定异步执行的时间,无法确定延时器的时间 2.使用 this.$nextTick( ( ) =&gt; { } ) this.$nexTick()的使用12345678910111213141516171819202122232425262728293031&lt;div id="app"&gt; &lt;h1&gt; &#123;&#123; num &#125;&#125; &lt;/h1&gt; &lt;button @click="fn"&gt; 按钮 &lt;/button&gt;&lt;/div&gt;data: &#123; num: 1 &#125;,methods: &#123; fn() &#123; // 点击按钮获取DOM中的值 // 此处还没有点击,所以获取的是 1 console.log(document.querySelector('h1').innerText) // -&gt; 1 this.num++ // 每次点击让num+1 // **如果此处获取,获取的还是1,因为DOM更新是异步的,没有更新这么快** console.log(document.querySelector('h1').innerText) // -&gt; 1 // 使用this.$nextTick() // **DOM更新数据后**,会自动执行这个方法里的回调 this.$nextTick( () =&gt; &#123; console.log(document.querySelector('h1').innerText) // -&gt; 2 &#125;) &#125; &#125; 异步DOM更新的总结: vue中DOM更新是异步的 vue中的数据发生改变,不会立刻将改变的数据更新到DOM中,而是确定数据不再变化了,一次性更新到视图中 为什么要异步DOM更新? 性能的考虑,操作DOM会引起回流与重绘,消耗性能 一般情况下,在vue中不会通过DOM操作页面中的数据 如果有需要的话,在this.$nextTick() 中获取DOM进行操作 this.$nextTick( ( )=&gt; { } ) ,在当前数据改变后DOM异步更新完毕会自动调用该方法里的回调]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XMLHttpRequest2.0新增]]></title>
    <url>%2F2018%2F05%2F13%2Fajax-XMLHttpRequest2.0%2F</url>
    <content type="text"><![CDATA[新增功能formData管理表单数据12341.实例化 var formdata = new FormData(form) form-&gt;表单的dom对象2.除表单外还有其他数据想上传 formdata.append("键","值")3.使用formdata必须用post请求,不用设置请求头 xhr.open("post","url地址")4.把formdata放到send小括号中 xhr.send(formdata) 文件上传要把选中的文件上传给服务器 和使用formData管理 表单数据一样,只不过不用传入表单的dom对象,第二步是把上传文件的文件对象,添加到formdata中 12formdata.append("file",fileInp.files[0])fileInp:上传文件的表单项dom对象.有个files对象,是个伪数组,第0项是需要的文件对象 显示文件进度信息监听文件上传事件: upload.onprogress **注:这个事件必须写在send之前** 12345upload.onprogress = function ( e )&#123; // e.loaded 已经上传了多少字节 // e.total 总共有多少字节 // toFixed(2)保留小数点后两位 &#125; timeout设置超时12345xhr.timeout = 3000;// 监听超时的事件xhr.ontimeout = function () &#123; &#125;]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算属性]]></title>
    <url>%2F2018%2F04%2F23%2Fvue-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed%2F</url>
    <content type="text"><![CDATA[如何使用 把计算属性写在computed里面 写起来想一个方法,用起来像一个属性代码:1234567891011&#123;&#123; num &#125;&#125;---html---data: &#123; num1: 2, num2: 3 &#125;,computed: &#123; num() &#123; return this.num1 + this.num2 &#125; &#125; 特点 一定要有返回值,返回的值就是在页面中显示的值 可以使用已知data里的数据 只要跟计算属性’相关的数据’发生了变化,该计算属性就会重新计算,里面的代码会重新执行 注意点 一定要有返回值 不要拿计算属性当方法用,他就是一个属性 计算属性的名字,不能和data里的数据的名字一样 使用场景 想要根据data里已知的数据,得到一个新值 这个新值,要求会随着相关的数据的改变而改变 为什么使用计算属性(使用计算属性的优点) 如果使用 插值表达式双花括号 或者 methods的话,每次数据变化就会引起指令和表达式的重新计算,太浪费性能,而计算属性只会让与计算属性有关联的数据重新计算]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async和await]]></title>
    <url>%2F2018%2F04%2F14%2Fes8-async-await%2F</url>
    <content type="text"><![CDATA[async和await是es8的语法用同步编写代码的方式,处理异步请求的一个方案,比promise处理的更彻底 async: 同步 说明: 修饰(修饰一个内部有异步操作的函数)await: 等待 说明: 等待(后面是一个promise实例对象)举个栗子:vue使用axios发送ajax请求渲染页面(假设全局配置好axios)两种方式比较:1234567891011121314// 这是使用promiseranderPage() &#123; this.$axios .get('url') // this.$axios.get('url')是promise实例对象 .then( res =&gt; &#123; // res是响应的数据 &#125;)&#125;// 这是使用async,await async randerPage() &#123; // async修饰内部有异步操作的函数 let res = await this.$axios.get('url') // await修饰promise实例对象 // res是响应的数据&#125;]]></content>
      <categories>
        <category>es8</category>
      </categories>
      <tags>
        <tag>promise</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computed计算属性和watch监听的区别]]></title>
    <url>%2F2018%2F04%2F13%2Fvue-computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[写法区别1.计算属性 写在copmputed里面,写起来像个方法,用起来像个属性,计算属性是个属性,不是方法 特点:– 1.必须有返回值– 2..可以使用data里已有的数据 只会随着’相关的属性’数据的变化而变化 2.监听 写在watch里面 使用场景1.什么时候用计算属性 由data中一直的值,得到一个’新值’,可以使用计算属性 计算属性只会根相关的属性有关,时刻更新 别人影响自己 2.什么时候使用监听器 监听自己发生的变化 监听data里的’已知的值’ 监听自己,影响别人]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式问题]]></title>
    <url>%2F2018%2F04%2F13%2Fvue-%E5%93%8D%E5%BA%94%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是vue的响应式可以正常的进行双向数据绑定,这就叫实现了响应式 响应式出现的问题 如果在data里有一个对象,忘了给对象添加属性,在methods中想要添加一个属性,在html插值表达式中使用了这个属性,会造成无法正常完成响应式的问题 例:123456789101112131415161718 // 1.双向数据绑定了obj的name属性,可是data里的obj没有name属性 &lt;input type="text" v-model='obj.name'&gt; &lt;button @click='fn'&gt;按钮&lt;/button&gt; // 1.1想要点击按钮,添加属性---html---data: &#123; obj: &#123; // 0.data里的obj对象里 忘了写属性 &#125;&#125;,methods: &#123; fn() &#123; // 2.想在事件中添加这个属性 this.obj.name = 'zssss' &#125;&#125; // 结果: 双向绑定失效,无法正常响应式 解决方法 使用this.$set( ) 方法 1234fn()&#123; this.$set(this.obj, 'name', 'zsssss')&#125; 使用说明: 第一个参数 : 把属性添加到哪里 this.obj 第一个参数 : 添加什么属性 ‘name’ 第三个参数 : 属性值]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[watch监听]]></title>
    <url>%2F2018%2F04%2F13%2Fvue-watch%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[watch 可以监听一个数据发生的变化 简单使用12345678910111213141516&lt;button @click="fn()"&gt;点击num+1&lt;/button&gt;---html--data: &#123; num: 2&#125;,methods: &#123; fn() &#123; this.num++ &#125;&#125;,watch: &#123; num(newVal, oldVal) &#123; console.log('新值', newVal); // 3 console.log('旧值', oldVal); // 2 &#125;&#125; 监听一个对象如果监听的数据是一个对象例如:1234567891011data: &#123; obj: &#123; name: '', isShow: false &#125;&#125;obj(newVal)&#123; &#125; 因为对象是复杂数据类型,所以监听的是一个地址 所以监听数据应该怎么做?1234567891011121314151617// 方式1: 通过监听对象, 拿到对象里最新的值obj: &#123; // 深度监听 deep: true, // 立马监听 immediate: true, // 处理 handler(newVal) &#123; console.log(newVal.name); &#125;&#125;// 方式2 : 可以直接监听对象里的属性'obj.name'(newVal)&#123; &#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收机制]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[分类1.标记清除法(最常用的方法) 当变量进入环境时,被标记为’进入环境’,离开时标记为’离开环境’, 垃圾回收器会把内存中的所有变量加上标记, 然后会去掉环境中的变量和被环境中的变量引用的变量 这些的标记, 在此之上还有标记的就是需要删除的变量2.引用计数法(不常用) 就是记录每个变量被引用的次数, 当引用次数为0时删除变量 谷歌浏览器的垃圾回收机制谷歌浏览器使用 V8引擎 的 GC算法 分代式 管理内存 将内存空间一分为二, 一半是新生代, 一半是老年代, 新生代里空间较小,生命周期也短,空间一分为二, 一个是使用的,一个是空闲的, 当使用的被内存填满时,GC算法将存活的变量转移到空闲的中, 这样一个来回就是一个新生代的算法过程, 并给每个经历了一个来回的变量做了标记 老年代理空间较大,生命周期也长, 进入老年代的是, 在新生代被打上标记的变量或者是很大的变量 老年代会遍历所有变量,标记所有存活的, 销毁所有失活的 新生代和老年代是同时进行的, 清除变量造成内存碎片, 当碎片过多时会启动压缩算法,压缩碎片,释放内存, 将存活的变量放进去]]></content>
      <categories>
        <category>浏览器机制</category>
      </categories>
      <tags>
        <tag>垃圾回收机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点透事件]]></title>
    <url>%2F2018%2F03%2F23%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-%E7%82%B9%E9%80%8F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[移动端点透事件模拟场景: 点击屏幕,弹出一个模态框,点击右上角按钮(A)关闭模态框的时候,会把关闭按钮后面的链接或input框等(B)触发 点透事件的原因zepto的tap事件是通过兼听绑定在document上的touch事件来完成tap事件的模拟的，并且tap事件是冒泡到document上触发的！touchstart事件,当手指触摸屏幕的时候会触发,这时候触发点击关闭模态框的事件,然而由于click事件有300ms延迟,所以当模态框已经关闭的时候,click事件还没有触发,所以click事件触发了模态框下面的链接或input框(绑定了click事件或者有默认click事件)等 解决方案方案1: 1.当B本身存在默认点击事件 将tap事件换成touchend事件,并禁止B的默认行为,阻止click事件的产生 阻止默认行为: event.preventDefault()方案2: 延迟300ms以后执行关闭模态框的操作,可添加过渡动画遮掩延迟方案3: 去除click事件的300ms延迟 使用fastclick.js]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>问题处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端手指事件]]></title>
    <url>%2F2018%2F03%2F22%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-%E6%89%8B%E6%8C%87%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[移动端的四个手指事件 touchstart 开始触摸时,触发 touchmove 手指滑动的时候,触发 touchend 手指离开屏幕的时候,触发 touchcancel 手指触摸,被一些系统事件打断了,触发 手指事件的事件对象 e.touches 屏幕的所有手指 e.changedTouches 发生改变的所有手指(增减,手指位置变化) e.targetTouches 目标对象上的所有手指]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插槽]]></title>
    <url>%2F2018%2F02%2F23%2Fvue-%E6%8F%92%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[插槽是什么是对组件的扩展,实现对组件或html结构的复用,可以通过slot插槽向组件内部指定位置传递内容,通过slot可以父子传参 插槽与data的区别 1.替换文字用data就能实现 2.替换标签或者组件只能用插槽实现 通俗理解slot标签的作用 1.就是占坑,在组件结构占好位置,使用组件标签时自动填坑 2.域名标签也就是坑有名字时,组件标签中使用slot=”myslot”的元素就会替换该位置对应内容 1.匿名插槽1234567891011组件模板:template:` &lt;div&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;`html结构:&lt;child&gt; &lt;p&gt;插槽的内容&lt;/p&gt;&lt;/child&gt; 使用说明: 在组件模板中使用slot占位,在使用组件标签时会把标签自动填充到对应模板占位的位置 2.域名插槽也叫具名插槽1234567891011组件模板:template:` &lt;div&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;slot name="n1"&gt;&lt;/slot&gt; &lt;/div&gt;`html结构:&lt;child&gt; &lt;p slot="n1"&gt;插槽的内容&lt;/p&gt;&lt;/child&gt; 使用说明: 在组件模板中,为占位的slot标签起个名字,在p标签中使用slot=”名字”相对应 3.作用域插槽如果子节点(类似上文的p标签)想访问组件的数据,默认是访问不到的这时候就要使用作用域插槽,用子传父的方式,实现通讯1234567891011121314151617181920组件模板:template:` &lt;div&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;slot name="n1" :fmsg="fmsg"&gt;&lt;/slot&gt; &lt;/div&gt;`,data()&#123; return &#123; fmsg: '组件中的数据' &#125;&#125;html结构:&lt;child&gt; &lt;template slot-scope="scope"&gt; &lt;p slot="n1"&gt;插槽的内容&lt;/p&gt; &#123;&#123; scope &#125;&#125; =&gt; &#123;&#123; "fmsg": "我是父级组件的数据" &#125;&#125; &#123;&#123; scope.fmsg &#125;&#125; =&gt; 我是父级组件的数据 &lt;/template&gt;&lt;/child&gt; 使用说明: 1.将要传的值绑定在slot标签上 2.在p标签外面加上一个template标签 3.在template标签中添加slot-scope=”scope” 4.就可以在p标签内使用数据了 注: scope是一个对象,里面存着传过来数据]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发和并行]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%85%B6%E4%BB%96-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[并发和并行​ 并发 同时发出去多条任务, 但是始终只有一条任务在执行​ 并行 同时发出去多条任务,所有的任务同时执行​ 并行是有限的,吃硬件,到极限会出现堵塞,并发不会,但并发比不过并行的效率]]></content>
      <categories>
        <category>浏览器机制</category>
      </categories>
      <tags>
        <tag>浏览器机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[click事件300ms延迟]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-click%E4%BA%8B%E4%BB%B6%E5%92%8Ctap%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[对于移动端来讲,click事件会有300ms延迟 原因: 移动端有双击缩放的功能,浏览器并不能判断你是想单击两次还是要双击缩放,所以,有个延迟300s,让浏览器判断用户是否再次点击了屏幕 解决方案: 1.设置视口,禁用用户缩放 2.若想保留用户缩放功能,将click事件改为使用tap轻触事件]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reset和normalize的区别]]></title>
    <url>%2F2018%2F02%2F13%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-reset%E5%92%8Cnormalize%E6%A0%BC%E5%BC%8F%E5%8C%96css%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[reset.css 将浏览器所有的默认样式都覆盖normalize 保留了许多浏览器的默认样式,如果有需要,再手动配置,更推荐这种方法]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2倍图和视口]]></title>
    <url>%2F2018%2F02%2F13%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-2%E5%80%8D%E5%9B%BE%E5%92%8C%E8%A7%86%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[2倍图比如说: 原图是一个是30px*30px的PNG图片 2倍图一个是60px*60px的PNG图片 3倍图一个是90px*90px的PNG图片 倍图设计的目的是为了让屏幕质量更高的手机,显示更清晰,所以需要准备大图片 视口1.宽度默认是980px 2.可以缩放 视口是一个介于html网页和手机浏览器的一个容器,是乔布斯提出的目的是为了让移动端访问pc网页的时候,不出现横向滚动条设置视口宽度为设备宽度 device-width 移动开发必须设置视口]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件修饰符]]></title>
    <url>%2F2018%2F02%2F08%2Fvue-%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[常用的按键修饰符@keyup.enter=”fn” 常用事件修饰符@click.prevent=’ ‘ 阻止默认行为(a标签的跳转等)@click.once=’ ‘ 只会触发一次事件]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么v-for要搭配key使用]]></title>
    <url>%2F2018%2F01%2F26%2Fvue-key%2F</url>
    <content type="text"><![CDATA[vue推荐: 使用v-for的时候,添加key属性 为什么呢? 因为vue有 “就地复用”策略: 如果不加key的话,在数组的前面添加,一个对象,文本框里的内容会根据 索引 实现一个就地复用 所以v-for的时候,添加一个属性 key 一般使用 id 而不是index , 因为顺序变了使用index就不准确了 :key = ‘item.id’以后使用v-for的时候请务必加上key值 1&lt;p v-for="item in list" :key="item.id&gt;&lt;/p&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue常用指令]]></title>
    <url>%2F2018%2F01%2F23%2Fvue-vue%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[v-text和v-html以及插值表达式的区别如果data里有一条数据: msg: 123v-text相当于innerText,不解析标签 123v-html相当于innerHTML,解析标签 123(加粗加大)这两个指令和标签属性一样,都是在标签里面使用的而插值表达式是在双标签中间的内容区域使用的,和v-text一样,不解析标签 v-bind和v-modelv-bind是数据单向绑定,用于绑定标签的属性比如: 测试 data:{ msg: ‘单向绑定的数据’ }v-model是数据双向绑定,用于表单元素 data:{ msg: ‘双向绑定的数据’ }v-bind可以简写 v-click绑定事件用的123456&lt;button v-on:click="rander()"&gt;&lt;/button&gt;methods:&#123; rander()&#123; alert('点击了') &#125;&#125; 可简写: 括号可传参 v-for遍历1234567891011121314151617&lt;p v-for="item in list"&gt; &#123;&#123; item &#125;&#125; &#123;&#123; item.id &#125;&#125; &#123;&#123; item.name &#125;&#125;&lt;/p&gt;data: &#123; list: [&#123; id: 1, name: 'zss' &#125;, &#123; id: 2, name: 'lss' &#125; ]&#125; v-show和v-if等于一个布尔值true显示 false隐藏12345&lt;p v-show="isShow"&gt;展示还是隐藏&lt;/p&gt;&lt;p v-if="isShow"&gt;展示还是隐藏&lt;/p&gt;data:&#123; isShow: true&#125; 区别: v-show相当于给标签加了一个display:block/none 的样式 v-if是创建或删除节点性能消耗: 正因为v-if是操作DOM元素,会引起回流与重绘,所以很消耗性能 所以如果显示与隐藏’比较频繁的话’,使用v-show 不频繁的话,使用v-if v-if v-else-if v-else12345678 &lt;!-- 三种情况的 --&gt;&lt;h1 v-if='age &gt;= 30'&gt;老年人&lt;/h1&gt;&lt;h1 v-else-if='age &gt;= 18 &amp;&amp; age &lt; 30'&gt;成年人&lt;/h1&gt;&lt;h1 v-else&gt;未成年&lt;/h1&gt;---html---data: &#123; age : 2 &#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源和跨域]]></title>
    <url>%2F2018%2F01%2F23%2Fajax-%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[同源同源的条件: 1.协议相同 2.域名相同 3.端口号相同 同时满足三个条件才可成为同源 同源最大特点: 同原网站之间共享cookie 同源策略限制的范围: 1.cookie,localStorage,indexDB 2.DOM 3.ajax请求 非同源网站之间不能共享这些数据 跨域什么是跨域: 往不同源的网页发送请求,就是跨域 因为浏览器有同源策略,ajax请求是可以出去的,但是响应的数据被浏览器拦截了,导致请求不成功 jsonp原理: 因为script,img,link这些标签不受同源策略的影响, jsonp就是利用了script标签不受同源的影响, 将php文件写在src中, 给后台发送请求的时候,把声明的函数名拼接在url后面,发送给服务器, 服务器返回这个函数的调用,他把返回的数据当做实参传进函数调用, 响应完成后,在响应的数据里就能拿到返回的数据了 jsonp只支持get请求,且要后台配合 跨域资源共享CORS ie10+支持 在请求头 中添加origin字段,指定域名 或 *:允许所有域名访问 jsonp兼容性好,仅支持get请求,使用麻烦 cors是浏览器支持,使用简单,不限制请求类型]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[token令牌]]></title>
    <url>%2F2018%2F01%2F15%2F%E5%85%B6%E4%BB%96-token%E4%BB%A4%E7%89%8C%2F</url>
    <content type="text"><![CDATA[token令牌作用用户登录成功时,服务器端会生成一个 token令牌并返回给客户端,客户端将token令牌保存下来(localStorage或cookie)客户端每次发送需要登录验证的请求时都携带这个token令牌,服务器端进行token令牌验证,验证通过,返回数据]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>储存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pc和移动端区别]]></title>
    <url>%2F2018%2F01%2F13%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-pc%E7%AB%AF%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1.屏幕尺寸 pc端 有版心 移动端 百分比适配2.浏览器兼容 pc端 h5c3支持较好 移动端 前缀-webkit-]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less基本使用]]></title>
    <url>%2F2018%2F01%2F13%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-less%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[css预处理器为了代码的可复用性,可维护性less文件需要编译 语法1.注释 /**/ 会被编译到css中去 // 不会被编译到css中去 2.变量 声明 @变量名:变量值 3.混入类 可以将类当成函数,在其他类中调用,不能传参,为了实现类的复用 4.函数 .类() 函数不会被编译到css中去 函数可以调用,可传参 函数有参数必须传参,不设参数要有默认值 5.less嵌套 后代选择器 直接嵌套编写 子代选择器 加上&gt; 交集选择器 &amp;表示自己 伪元素选择器 &amp;: 6.导入 @impoprt &quot;文件名&quot; 文件后缀名可省略 用于大型项目的模块划分 7.less运算 加减乘除 内置运算]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生ajax发送请求]]></title>
    <url>%2F2018%2F01%2F13%2Fajax-%E5%8E%9F%E7%94%9Fajax%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[form和ajax区别0.都可以给后台发送请求 1.form发出去的请求是同步的,ajax是异步的 2.form发出请求后,页面会发生跳转,ajax不会发出跳转 js原生实现ajax发送请求get请求1234567891.实例化xmlhttprequest对象 var xhr = new XMLHttpRequest()2.设置请求行 xhr.open('get','demo.php?name=zs&amp;age=18')3.设置请求头 // get请求可以忽略4.设置请求主体,并发送数据 xhr.send(null) // get请求,写null或不写 post请求1234567891.实例化xmlhttprequeat对象 var xhr = new XMLHttpReauest()2.设置请求行 xhr.open('post','demo.php')3.设置请求头 xhr.setRequestHeader('content-type','application/x-www-form-urlencoded') // post请求设置请求的目的是让服务器知道请求中有参数,是表单的编码类型,不写的话服务器拿不到数据4.设置请求主体,并发送数据 xhr.send('name=zs&amp;age=19') 共有的最后一步1234567891011125.监听响应 // 触发条件:当readystate状态发生变化的时候(只有当状态码是2,3,4的时候才会触发) xhr.onreadystatechange = function ()&#123; if(xhr.readyState == 4)&#123; // 状态码为4,请求和响应完成 if(xhr.status == 200)&#123; // 状态码200,请求和响应成功 var res = xhr.responseText // responseText 获取响应的主体的内容 &#125; &#125; &#125; get请求和post请求的区别:1.get请求的参数在地址栏中,在请求行中,在地址栏中,不安全,有长度限制 2.post请求的参数不在地址栏中显示,在请求主体中,相对安全,没有长度限制]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种移动开发分类]]></title>
    <url>%2F2018%2F01%2F10%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-%E4%B8%89%E7%A7%8D%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1.原生App直接基于操作系统进行开发的应用程序 优点: 1.运行在操作系统送,性能好 2.可访问手机的硬件设备 3.可以离线访问 缺点: 1.成本高 2.跨平台性差 3.更新维护麻烦 2.webApp直接运行在浏览器中,使用html/css/js开发 优点: 1.跨平台性好,只要游浏览器就可以运行 2.成本低 3.更新维护方便 缺点: 1.依赖网络,不能离线访问 2.性能相对来说差 3.不能直接访问手机硬件设备 3.混合App结合,webApp外层套了一个原生App的壳 优点: 1.跨平台性好 2.成本低 3.可直接访问手机硬件设备 缺点: 要更新版本 一般开发流程: webApp —(套个壳)&gt;&gt; 混合App —(高性能)&gt;&gt; 原生App]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化和组件化]]></title>
    <url>%2F2018%2F01%2F01%2F%E5%85%B6%E4%BB%96-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8C%E7%BB%84%E4%BB%B6%E5%8C%96%2F</url>
    <content type="text"><![CDATA[由于前端页面和逻辑越来越复杂,于是模块化,组件化相继而生为了代码的可复用性 模块化和组件化的区别 关注的重点不同模块化: 关注代码逻辑组件化: 关注UI界面 模块化规范1.AMD - require.js 异步 依赖前置 2.CMD - sea.js 有同步也有异步 依赖后置 3.commonJS - node.js 同步的 4.ES6标准模块化规范 require和import的区别- require出现在AMD,CMD,commonJS中 - import是ES6提出的模块化规范 - 我的理解是require是非官方提出的模块化规范, - import是官方提出的模块化规范]]></content>
      <categories>
        <category>模块化和组件化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[播放器]]></title>
    <url>%2F2017%2F12%2F31%2FH5-%E6%92%AD%E6%94%BE%E5%99%A8%2F</url>
    <content type="text"><![CDATA[### 播放器标签 是进度条控件 video.play() 播放video.parse() 暂停this.requestFullScreen() 全屏 一般使用兼容写法 ie不支持 video.currentTime 获取或设置当前已经播放的秒数video.duration 获取当前视频总长度 timeupdate 事件 只要视频播放就会一直触发的事件 video.volume 设置或者返回当前视频的音量video.volume = 0.2 设置声音是 20%video.volume = 0 设置静音 切换视频: 就是改变video的src地址]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>播放器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件读取和预览]]></title>
    <url>%2F2017%2F12%2F30%2FH5-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627&lt;input type="file" id="fileInput"&gt;&lt;div&gt; &lt;/div&gt;&lt;script&gt; // h5新增的 fileReader 可以读取用户选择的文件 var fileInput = document.getElementById('fileInput'); var div = document.querySelector('div') fileInput.addEventListener('change', function () &#123; console.log(this); // 1.获取选中的文件 var file = this.files[0] console.log(file); // 2.创建读取器 var fileReader = new FileReader() // 3.调用方法,读取文件 fileReader.readAsDataURL(file) // 4.读取文件需要时间,一旦读取完成,会调用 onload 方法 fileReader.onload = () =&gt; &#123; var result = fileReader.result; // 将读取的内容设置给img的src div.innerHTML = '&lt;img src="' + result + '"&gt;' &#125; &#125;) 创建读取器 -&gt; 读取文件(读取哪个文件,所以要获取) -&gt; 把读取后的内容(地址)赋值给盒子的src]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>文件读取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dpr-设备像素比]]></title>
    <url>%2F2017%2F12%2F23%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-dpr%2F</url>
    <content type="text"><![CDATA[设备无关像素就是css像素,是 乔布斯提出的 dpr 设备像素比dpr = 物理像素 / css像素 获取dpr `window.devicePixelRatio`]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>像素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地理位置定位]]></title>
    <url>%2F2017%2F12%2F13%2FH5-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[123456789101112// 获取当前地理位置navigator.geolocation.getCurrentPosition( // 成功的回调 (position) =&gt; &#123; console.log("获取地理位置成功"); console.log(position); &#125;, // 失败的回调 (error) =&gt; &#123; console.log("获取地理位置失败"); &#125;)]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>地理位置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络状态]]></title>
    <url>%2F2017%2F12%2F13%2FH5-%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[判断是否在线navigator.onLine 切换网络状态触发的事件onLine 切换到在线时触发offLine 切换到离线时触发1234567window.addEventListener("onLine", () =&gt; &#123; console.log("切换到在线时触发");&#125;)window.addEventListener("offLine", () =&gt; &#123; console.log("切换到离线时触发");&#125;)]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>网络状态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种布局方式]]></title>
    <url>%2F2017%2F12%2F13%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-%E4%B8%89%E7%A7%8D%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[流式布局1.高度写死,宽度自适应(宽度百分比) 2.对大屏幕不友好,会拉长 响应式布局1.一套代码,多终端适配 原理:动态检测屏幕的宽度变化,给不同的盒子设置宽高或显示隐藏的样式,来实现多终端适配屏幕大小分类: 屏幕分类 大小 设备 超小屏幕 0~768px 手机 小屏幕 768~992px 平板 中屏幕 992~1200px 老式机 大屏幕 &gt;1200px 笔记本电脑 rem布局1.能适配所有的屏幕 rem是个相对单位,相对html根字体大小(16px)em是相对自身父标签的字体大小原理:以rem为单位,根据html跟字体大小,转化为rem,动态设置不同屏幕的html跟字体大小基准值: 设计图下的尺寸中html跟字体大小怎么确定基准值是多少:当前屏幕宽 / 设计图尺寸 = html跟字体标签 / 基准值使用媒体查询实现rem适配,性能好,但不能一次性适配所有屏幕使用原生js实现rem适配,可以一次性适配所有屏幕,实时适配,性能不好使用淘宝flexible 定义的基准值 = 设计图尺寸 / 10]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义属性操作]]></title>
    <url>%2F2017%2F12%2F13%2FH5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[datasetdata是一个对象,里面存着所有的自定义属性,但是要求所有的自定义属性以data-开头 使用 1.查询 DOM.dataset DOM.dataset.属性名2.添加 DOM.dataset.属性名 = “属性值”3.修改 DOm.dataset.属性名 = “属性值” 实例123456789101112131415&lt;div data-id="2" data-name="zs"&gt;我是盒子&lt;/div&gt;&lt;script&gt; var div = document.querySelector('div') console.log(div.dataset); // 查询 console.log(div.dataset.id); console.log(div.dataset.name); // 添加 div.dataset.age = "20" // 修改 div.dataset.name = "ls"]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>自定义属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增类名操作]]></title>
    <url>%2F2017%2F12%2F12%2FH5-%E6%96%B0%E5%A2%9E%E7%B1%BB%E5%90%8D%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[添加类名DOM.classList.add(“想添加的类名”) 移除类DOM.classList.remove(“要移除的类名”) 切换类名DOM.classList.toggle(“要切换的类名”)有这个类名就移除,没有这个类名就添加 判断是否包含类DOM.classList.contains(“要判断的类名”) 实例1234567891011121314151617181920212223&lt;div class="aa"&gt;我是盒子&lt;/div&gt; &lt;script&gt; // H5以前操作类名 // var div = document.querySelector('div') // div.className += " bb" // div.className += " cc" // H5新增一系列操作类名的方式 var div = document.querySelector('div') // 添加 div.classList.add("pp") // 移除 div.classList.remove("aa") // 判断是否包含 var isHave = div.classList.contains("pp") console.log(isHave); // true // 切换类,啥意思呢,没有这个类就添加上,有这个类就移除 div.classList.toggle("qiehuan") div.classList.toggle("qiehuan") // 这个标签身上有多少个类 console.log(div.classList.length);]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>类名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期]]></title>
    <url>%2F2017%2F11%2F25%2Fvue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[三个阶段1.挂载阶段(进入页面)2.更新阶段(数据发生变化)3.销毁阶段(卸载阶段) 1.挂载阶段分为三个阶段1.数据响应式阶段 beforeCreate 拿不到data数据和method方法 created 能拿到data数据和method方法 常在created阶段发送ajax请求 2.找模板 找到el指定的边界 看是否有template标签– 有就使用template里面呢的内容去编译 没有就添加template标签 3.DOM渲染 beforeMount DOM渲染之前 mounted DOM渲染之后 常在mounted中获取DOM,使用ref 2.更新阶段1.beforeUpdate 数据更新前2.updated 数据更新后 3.销毁阶段1.beforeDestory 销毁之前 当销毁的时候,vue会清除自己的内容但是我们手动添加的东西不会销毁,要在这里手动销毁 2.destoryed 销毁之后]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通讯]]></title>
    <url>%2F2017%2F11%2F20%2Fvue-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[父传子1.通过属性绑定将数据传递给子组件2.在子组件中,通过配置项props接收数据—例如:在父组件有一条数据list,想传给子组件12345678&lt;div id="#app"&gt; &lt;child :fatherlist="list"&gt; &lt;/child&gt; // 父组件属性绑定传递&lt;/div&gt;...// 子组件中使用props:["fatherlist"] //子组件通过props接收,使用&lt;li v-for="item in fatherlist"&gt;&lt;/li&gt; 子传父回调函数思想1.父组件提供一个方法,用来接收子组件的数据2.将这个方法传递给子组件,通过自定义事件3.子组件调用这个方法, 使用this.$emit()发射数据—例如:12345678910111213// 1.父组件提供一个方法 parent()&#123; &#125;// 2.通过自定义事件传递给子组件&lt;div id="#app"&gt; &lt;child @father="parent"&gt;&lt;/child&gt;&lt;/div&gt;// 3.子组件调用这个方法son(sondata)&#123; this.$emit('father',sondata)&#125;// 这样在父组件parent方法中能获取到子组件传递的sondata了 this.$emit() 参数1是自定义事件名 参数2是要传递的数据 非父子组件间传递数据使用事件总线传递1.注册事件总线对象2.发送数据3.接收数据—例如12345678// 1.注册事件总线const bus = new Vue()// 2.发送数据bus.$emit('通信指令',数据)// 3.接收数据bus.$on('通信指令',res =&gt; &#123; res =&gt; 数据&#125;) 通信指令名字随便起,要一致]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue双向绑定原理]]></title>
    <url>%2F2017%2F11%2F13%2Fvue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[底层依据使用的是es5中的 Object.defineProperty()方法 这个方法是用来给对象添加或修改属性的Object.defineProperty(参数1,参数2,参数3)参数1: 要个谁添加属性参数2: 添加什么属性参数3: 属性描述符(定义属性的具体描述)其中属性描述符 有两个方法12345678set(newVal)&#123; &#125;// 赋值调用set方法get()&#123; return ...&#125;// 获取调用get方法 V -&gt; M 从视图层到数据层的单向绑定,通过表单的iinput事件就能实现M -&gt; V 难点是从哪个数据层到视图层的单向绑定怎么让视图层知道数据变化了呢可以利用set方法我们使用Object.defineProperty监听属性,当数据改变时,触发set方法,更新view层]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5c3兼容性问题及解决]]></title>
    <url>%2F2017%2F10%2F03%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-h5c3%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[ie678不支持css3媒体查询 使用respond.js这个插件(底层是js监听屏幕变化) ie678不支持h5语义化标签 解决:底层— 手动创建标签并将其转化为块级元素一般使用html5shiv插件 条件注释 只有ie认识,且是ie9以下才认识,专门用来解决ie兼容性问题]]></content>
      <categories>
        <category>H5C3</category>
      </categories>
      <tags>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语义化标签]]></title>
    <url>%2F2017%2F10%2F03%2FH5%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[新增语义化标签header,nav,aslide,footer,section… 兼容问题ie8及以下不支持 1.原生解决方案 1.在浏览器解析html新标签元素之前,动态创建新标签元素 2.动态创建出来的标签是行内元素,要手动转成块级2.使用html5shiv 使用条件注释(: 只有ie9及以下版本认识,专用解决ie的兼容问题) lte小于等于 lt小于 gt大于 gte大于等于 在小与等于ie8的浏览器中,使用兼容处理 底层还是动态创建标签123&lt;!--[if lte IE 8]&gt; &lt;script src="./html5shiv.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this的指向]]></title>
    <url>%2F2017%2F10%2F03%2Fjs-this%2F</url>
    <content type="text"><![CDATA[this的指向 1.直接打印this会怎样123console.log(this)// 浏览器 =&gt; window// node.js =&gt; &#123;&#125; 2.函数中this的指向 1234567function fn() &#123; console.log(this)&#125;fn()// 浏览器 =&gt; window // node.js =&gt; global// 严格模式下都是undefined 3.对象中this的指向12345678const obj = &#123; name: 'zs', fn: function () &#123; console.log(this); &#125; &#125; obj.fn() // obj nod.js,严格模式同 4.构造函数中this的指向 1234567function Person(name, age) &#123; this.name = 'zs'; &#125; const p = new Person() p.age = 99 console.log(p); //this指向实例p 5.小坑,定时器/延时器中this的指向12345 setInterval(function () &#123; console.log(this);&#125;, 3000) // 浏览器 =&gt; window &lt;= 严格模式 // node.js =&gt; global &lt;= 严格模式 改变this的指向123456789101112131415function fn() &#123; console.log(this)&#125;// 一般来说 , 这个this指向的是window// 1.call // 然后我们调用call方法fn.call('yoo') // 改变了this的指向,让this指向了'yoo'这个字符串// 2.apply // 然后我们调用apply方法fn.apply('yoo') // 改变了this的指向,让this指向了'yoo'这个字符串// 3.bind// 然后我们调用bind方法const newFn = fn.bind('yoo') // 使用bind方法会返回一个新的函数newFn() // 改变了this的指向,让this指向了'yoo'这个字符串 call和apply的区别 123456789101112131415161718192021222324const obj = &#123; name: 'yooo'&#125;function rename(x, y) &#123; console.log(x, this.name, y);&#125; // rename('a', 'b') // a, b // ---------- // rename.call(obj, 'a', 'b') // this指向obj a, yooo ,b // ---------- // rename.apply(obj, 'a', 'b') // 会报错 CreateListFromArrayLike called on non-object // 说明apply的参数要传一个参数数组 // rename.apply(obj, ['a', 'b']) // this指向obj a,yooo ,b // ---------- // const newname = rename.bind(obj, 'a', 'b') // newname() // this指向obj , a,yooo,b // const newname = rename.bind(obj, ['a', 'b']) // newname() // ["a","b"],"yoo",undefined // b-undefined,说明把数组当成一个整体传递了 // 所以bind的参数要传一个参数列表 综上说述:1.call,apply,bind第一个参数都是this的指向2.call和bind第二个参数都是参数列表3.apply第二个参数是参数数组 bind和call,apply 的区别12345678910111213function fn() &#123; console.log(this)&#125; const newFn = fn.bind('two') newFn() // 我们使用bind改变了this的指向,打印this指向'two' newFn.call('one') // 我们想使用call改变this的指向,打印this还是指向'two' newFn.apply('one') // 我们想使用apply改变this的指向,打印this还是指向'two' const newNewFn = newFn.bind('one') newNewFn() // 我们想使用bind改变this的指向,打印this还是指向'two' 综上说述:如果已经用了bind改变了this的指向,再调用call,apply,bind,不会改变this的指向了 箭头函数this的指向 箭头函数里的this指向不是自己决定的,是所属环境决定的当箭头函数声明的时候,所在环境this指向什么,箭头函数this就指向什么12345678910111213141516171819202122232425262728293031323334353637// 1. 在函数环境里声明箭头函数打印thisfunction outer() &#123; console.log("环境中的this指向:", this); // window (() =&gt; &#123; console.log("箭头函数的this指向:", this); // window &#125;)()&#125;outer()// 2. 直接在箭头函数里打印thisconsole.log("环境中的this指向:", this); // window(() =&gt; &#123; console.log("箭头函数的this指向:", this); // window&#125;)()// 3. 在对象里声明箭头函数打印thisvar obj = &#123; fn: () =&gt; &#123; console.log(this); &#125;&#125;obj.fn() //window 因为环境是window.obj// 4.在对象的方法里声明箭头函数打印thisvar obj = &#123; fn: function () &#123; console.log(this); // 调用obj.fn() 这里打印 =&gt; obj (() =&gt; &#123; console.log(this); // 打印obj 因为所在环境是obj &#125;)() &#125;&#125;obj.fn() 箭头函数不能改变this的指向上文我们说到,箭头函数里的this指向不是自己决定的,是所属环境决定的所以箭头函数本身是不能改变this指向的1234567891011121314151617var obj = &#123; name: 'zs', fn: function () &#123; console.log(this); &#125; &#125; obj.fn.call('yooo') // 'yooo' 普通函数可以改变this指向 var obj = &#123; name: 'zs', fn: () =&gt; &#123; console.log(this); &#125; &#125; obj.fn.call('yooo') // window 箭头函数不能改变this指向]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2017%2F09%2F23%2Fjs-%E6%95%B0%E7%BB%84-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序 在此之前,先看一下这些 1. 如何 交换 两个数据的顺序 123456let a = 1let b = 2let temp = a // temp = 1 a = b // a = 2b = temp // b = 1 // a,2 b,1 2.如何把一个最大值放到数组的最后 123456789const arr = [4,3,2,1]for (let i = 0; i &lt; arr.length; i++)&#123; if(arr[i] &gt; arr[i+1])&#123; let temp = arr[i] arr[i] = arr[i+1] arr[i+1] = temp &#125;&#125;// arr =&gt; [3,2,1,4] 3.假设成立法 判断数组中的数是否都是奇数123456789101112131415const arr = [3,4,9,7]// 1.假设都是奇数let flag = truefor (let i = 0; i &lt; arr.length; i++)&#123; if( arr[i] % 2 == 0 )&#123; // 2.找到打脸的,他是奇数 flag = false &#125; &#125; // 3.判断 if(flag)&#123; console.log('都是奇数') &#125;else&#123; console.log('不都是奇数,有偶数') &#125; 4.冒泡排序 123456789101112131415161718const arr = [2,8,4,1]for (let j = 0; j &lt; arr.length; j++)&#123; for (let i = 0; i &lt; arr.length; i++)&#123; if(arr[i] &gt; arr[i+1])&#123; let temp = arr[i] arr[i] = arr[i+1] arr[i+1] = temp &#125; &#125;&#125;// 如果只执行里面的fori循环 只比较一次 // 把最大值放到了最后面 arr =&gt; [2,4,1,8] // 所以在外面要在套一个for循环,进行遍历次数(比较几次)// arr =&gt; [1,2,4,8]// 每一次循环,都把最大值放到后面 5.优化冒泡排序 123456789101112131415const arr = [2,8,4,1]// 其实只要进行三次比较,就能排好序// 1.[2,4,1,8] 2.[2,1,4,8] 3.[1,2,4,8]// 所以外循环可以少遍历一次for (let j = 0; j &lt; arr.length - 1; j++)&#123; // 第一次少遍历一次,往后每一次都少遍历j次 for (let i = 0; i &lt; arr.length - 1 - j; i++)&#123; if(arr[i] &gt; arr[i+1])&#123; let temp = arr[i] arr[i] = arr[i+1] arr[i+1] = temp &#125; &#125;&#125; 6.使用假设成立法再优化冒泡排序 12345678910111213141516171819const arr = [2,8,4,1]// 1.假设排好序了let flag = truefor (let j = 0; j &lt; arr.length - 1; j++)&#123; for (let i = 0; i &lt; arr.length - 1 - j; i++)&#123; if(arr[i] &gt; arr[i+1])&#123; // 2.找到打脸的,他没排好序 let temp = arr[i] arr[i] = arr[i+1] arr[i+1] = temp &#125; &#125; if(flag)&#123; // 3.判断 // 如果排好序了,就终止循环 break &#125; // 如果没有排好序,就继续执行,直到都排好了执行break&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap简单使用]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-bootstrap%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[bootstrap 依赖于jquery3.XX版本 按钮类btn-default 默认白色 btn-success 绿色 btn-danger 红色 btn-primary 深蓝色 按钮大小btn-lg btn-md(默认) btn-sm btn-xs 响应式布局容器container 响应式版心 默认15px左右padding container-fluid 流式布局容器 默认15px左右padding row类用于抵消父元素的默认左右padding 栅格系统将页面分成12份,按照份数分配子元素空间 col-屏幕类型-份数分配 屏幕类型: lg,md,sm,xs 对齐方式text-left text-center text-right 表格类table table-bordered表格边框 table-hover 控制显示隐藏hidden 所有屏幕隐藏 hidden-lg 大屏隐藏 hidden-md 中评隐藏 hidden-sm 小平隐藏 hidden-xs 超小平隐藏 组件字体图标 导航条 面包屑导航 下拉菜单 进度条 js插件模态框 轮播图]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie,localStorage,sessionStorage]]></title>
    <url>%2F2017%2F09%2F14%2FH5-web%E5%82%A8%E5%AD%98%2F</url>
    <content type="text"><![CDATA[比较 类型 大小 生命周期 数据是否可以多页面共享 cookie 4K 默认一个会话,可设置,关闭当前窗口,就销毁了 多页面共享 localStorage 5M 永久储存,只要用户不手动删除 可以多页面共享 sessionStorage 5M 一个会话,关闭当前窗口,就销毁了 不能多页面共享 indexedDB 取决于计算机硬件大小 永久储存 可以多页面共享 localStorage的api数据在本地储存的格式是json字符串1.设置 localStorage.setItem(‘key’,’value’) 2.获取 localStorage.getItem(‘key’) 3.移除 localStorage.removeItem(‘key’) 4.清空(所有) localStorage.clear()]]></content>
      <categories>
        <category>浏览器机制</category>
      </categories>
      <tags>
        <tag>web储存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http和https]]></title>
    <url>%2F2017%2F09%2F12%2F%E5%85%B6%E4%BB%96-http%E5%92%8Chttps%2F</url>
    <content type="text"><![CDATA[http和https区别http 是超文本传输协议,信息是明文传输,https 是ssl加密传输协议,信息加密传输http和https使用不同的链接方式,用的端口也不一样所以http和https之间不能相互访问,协议和端口号不一样,不符合同源策略]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端seo优化]]></title>
    <url>%2F2017%2F09%2F10%2F%E5%85%B6%E4%BB%96-SEO%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端seo优化1.创建唯一且准确的网页标题2.meta标签的网页描述信息准确总结网页内容3.使用H5语义化标签4.合理使用的alt属性5.将重要的内容放在html代码的前面6.扁平化网页结构,减少嵌套结构]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise]]></title>
    <url>%2F2017%2F06%2F29%2Fes6-promise%2F</url>
    <content type="text"><![CDATA[回调地狱以前处理异步操作,我们使用的是回调函数的方式这样的话存在一个问题,如果简单的还好,如果异步操作麻烦,可能会出现回调地狱的问题如下:12345678910111213141516171819202122232425262728 // 发送ajax请求数据时:// 第一个请求$.ajax(&#123; url: '', type: '', success: res =&gt; &#123; // 第二个请求 $.ajax(&#123; url: '', type: '', success: res =&gt; &#123; // 第三个请求 $.ajax(&#123; url: '', type: '', success: res =&gt; &#123; // 第四个请求 $.ajax(&#123; url: '', type: '', success: res =&gt; &#123;&#125; &#125;); &#125; &#125;); &#125; &#125;); &#125;&#125;); 这样一层套一层,不直观,理解起来困难 es6的promise所以es6提出了promise语法,想用同步编写代码的方式,来处理异步操作1234promise.then(第一个请求).then(第二个请求).then(第三个请求) 优雅直观,修改代码也方便 promise的封装原理123456789101112131415161718192021const p = new Promise( (resolve,reject) =&gt; &#123; resolve() // 成功调用resolve方法 reject() // 失败调用reject方法&#125;) p .then( res =&gt; &#123; // 成功 &#125;) .catsh( err =&gt; &#123; // 失败 &#125;) // 1.p就是Promise实例对象 // 2.只有Promise实例对象才可以在后面 .then // 3.例如 vue中发送ajax请求使用axios: axios .get() .then() // 这里的axios.get()就是一个promise实例对象 // xxx.then xxx就是promise实例对象 all和raceall1234Promise.all().then()// 等all里所有的异步操作全部完成后,才会执行then里的操作 race1234Promise.race().then()// 只要race里有一个异步操作完成,就会执行then里的操作 promise的三个状态pending: 等待resolved: 成功调用rejected: 失败调用]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>promise</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构赋值]]></title>
    <url>%2F2017%2F06%2F25%2Fes6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[解构赋值对象的解构赋值1234567891011121314151617181920212223242526const obj = &#123; id: 99, name: '小明', my_age: 18&#125;// 这是我们es5使用的方法function copy() &#123; this.id = obj.id this.name = obj.name // 想把my_age改成使用变量myAge接收 this.myAge = obj.my_age console.log(id, name, myAge)&#125;// copy(obj) // 99 '小明' 18// 这是es6解构赋值语法const &#123; id, name, // 想把my_age改成使用变量myAge接收 my_age: myAge&#125; = objconsole.log(id, name, myAge) 数组的解构赋值123456789101112131415161718192021222324252627282930const arr = [1, 2, 3]// 1. 想要在数组内前面或后面添加一个元素// es5的做法arr.push('a')console.log(arr); // [1,2,3,'a']arr.unshift('b')console.log(arr); // ['b',1,2,3]// es6语法const arr1 = [...arr, 'a']console.log(arr1); // [1,2,3,'a']const arr1 = ['b', ...arr]console.log(arr1); // ['b',1,2,3]// 2. 想把两个数组合并成一个数组// es5语法const arr3 = [4, 5, 6]const arr4 = arr.concat(arr3)console.log(arr4); // [1,2,3,4,5,6]// es6语法const arr3 = [4, 5, 6]const arr4 = [...arr, ...arr3]console.log(arr4); // // [1,2,3,4,5,6]]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2F2017%2F06%2F20%2Fajax-json%2F</url>
    <content type="text"><![CDATA[JSON全名:js对象标记法 JSON对象和JS对象区别JSON对象的属性名必须加双引号 JSON字符串和JS对象的转化12JS -&gt; JSON JSON.stringify(JS对象)JSON -&gt; JS JSON.parse(JSON字符串)]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2017%2F05%2F24%2Fjs-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组合并的方法es51234var a1 = [1,2]var a2 = [3,4]var a = a1.concat(a2)a =&gt; [1,2,3,4] es61234const a1 = [1,2]const a2 = [3,4]const a = [ ...a1 , ...a2 ]a =&gt; [1,2,3,4] 数组去重的方法es512345678910var arr = [1,1,1,2,2,3]var newArr = []arr.forEach( (item,index) =&gt; &#123; // indexOf: 查找数组中某个元素第一次出现的位置,若找不到,返回 -1 if(newArr.indexOf(item) === -1)&#123; // 如果newArr中没有这一项,就把这一项添加到newArr中 newArr.push(item) &#125;&#125;)newArr =&gt; [1,2,3] es6123const arr = [1,1,1,2,2,3]const newArr = new Set(arr)// 重复元素在Set中自动被过滤 数组的增删12345678910111213const arr = [1,2,3,4]// 在数组后面添加一个'a'arr.push('a') =&gt; [1,2,3,4,'a']// 在数组前面添加一个'b'arr.unshift('b') =&gt; ['b',1,2,3,4]// 在数组后面删除一位arr.pop() =&gt; [1,2,3]// 在数组前面删除一位arr.shift() =&gt; [2,3,4] 数组翻转12const arr = [1,2,3]arr.reverse() =&gt; [3,2,1] 数组拼通过连接符接成字符串12const arr = [1,2,3]const newArr = arr.join('-') =&gt; 1-2-3 数组查找元素 indexOf 从前往后找,第一次出现的位置,找不到返回 -1lastIndexOf 从后往前找 截取数组12345const arr = [0,1,2,3,4]const newArr = arr.slice(0,2) newArr =&gt; 返回截取的内容,从下标第0项,截取长度2,返回一个新数组 =&gt; [0,1]const n2 = arr.slice(2) // =&gt; 从下标第2项,截取到最后 =&gt; [2,3,4]const n3 = arr.slice() // =&gt; 截取全部 =&gt; [0,1,2,3,4] 数组splice方法12345678910const arr = [1,2,3,4,5]// 1.删除arr.splice(起始下标,删几个) arr.splice(2,2) // [1,2,5]// 2.替换arr.splice(起始下标,删几个,替换的内容) arr.splice(1,2,'a') // [1,'a',4,5]// 3.添加 (注意添加到的位置)arr.splice(起始下标,0,添加的内容) arr.splice(3,0,'b') // [1,2,3,'b',4,5] 清空数组的几种方式123arr.splice(0,arr.length) // 从下标0开始,删除数组的长度个,即删除全部arr.length = 0 // 将数组长度赋值为0arr = [] // 将数组赋值为一个空数组 数组排序 冒泡排序]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[if,switch,while,continue,break,for]]></title>
    <url>%2F2017%2F05%2F23%2Fjs-%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[if 太常用太简单,不说了 switch123456789switch( n )&#123; case 1: 执行代码块1 break case 2: 执行代码块2 break default: n 与case1 case2不同执行的代码块&#125; 原理: n的值会与每个case的值作比较,如果匹配,会执行相应的代码块,否则不会执行,往下继续运行每句结束必须要break while 和 do while 语法: while(条件){ 循环体 } do { 循环体 } while (条件)do while 和 while 不同的是. 他会保证让循环体至少会执行一次, 因为他是先执行代码然后在判断条件 for 太常用太简单,不说了 break和continue break是彻底结束当前循环,直接执行循环体后面的代码continue是逃过本次循环,然后整个循环体会继续执行]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>条件语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据类型]]></title>
    <url>%2F2017%2F05%2F22%2Fjs-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[js数据类型js有6种数据类型 5种简单数据类型(值类型,基本数据类型,原始数据类型) 1.number 2.string 3.boolean 4.null 5.undefined 1种复杂数据类型(引用类型) 1.object es6新增了一个symbol数据类型 所以现在是7种数据类型 number,string,boolean,null,undefined,object,symbol 值类型存的是值,引用类型存的是地址(引用) 简单数据类型是没有方法的,为了操作简单数据类型,要把简单数据类型转化包装(转化)成复杂类型,这就是基本包装类型,不过这不需要我们去包装,浏览器会默认包装 为什么typeof null === ‘object’ 按道理来说,null是简单数据类型,object是复杂数据类型,是属于不同的数据类型,那为什么null的数据类型是object呢其实这是一个历史遗留问题在js刚出来的时候,只有5种数据类型,有object类型,没有null类型,只是把null当做object的一种特殊值后来null独立出来了,那时候为什么没有吧null和object分开呢,这是为了兼容以前的代码,所以这个问题就被遗留到了现在 undefined和null undefined: 一个变量,只声明,未赋值null: 表示一个空对象指针 undefined == null 在没了解到这个之前,我们很容易的想到 undefined转换成布尔值是false,null转换成布尔值也是false,所以undefined == null, 其实这种想法是不对的在javascript规范中提到:在比较相等性之前,不能将null和undefined转换成其他值,并且规定null和undefined是相等的为什么呢,因为规范认为,既然undefined和null的行为很相似,都表示一个无效的值,那么他们所代表的内容也有相似性,所以有undefined == nullundefined === null =&gt; false 数据类型不一样 NaN 属于number类型,代表非数值 Not a NumberNaN与任何是都不相等,包括和NaN自身]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典布局]]></title>
    <url>%2F2017%2F04%2F23%2Fcss-%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[两边固定,中间自适应就是所谓的圣杯布局,双飞翼布局 这种两边固定,中间自适应的布局我整理了三种常用的方法:注意:实现这种布局时,要先写主体部分(自适应的部分),再写固定的部分 1.使用浮动 1.两边设置一左一右浮动2.主体部分设置overflow:hidden 2.使用定位 1.两边设置定位,分别定在左上角和右上角2.给父盒子设置padding,长度是固定盒子的宽度 3.使用flex布局 1.给父盒子设置display-flex2.给主体部分设置 flex:1 圣杯布局和双飞翼布局的不同点圣杯布局和双飞翼实现的效果是一样的,但是使用方法不一样,圣杯布局使用的是定位+padding,双飞翼布局使用的是定位+负margin]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie和session]]></title>
    <url>%2F2017%2F03%2F23%2F%E6%B5%8F%E8%A7%88%E5%99%A8-cookie%E5%92%8Csession%2F</url>
    <content type="text"><![CDATA[cookie和sessioncookie和session的区别cookie是储存在浏览器端的session是储存在服务器端的 session机制当浏览器第一次发送请求时,对应的服务器中会生成一个sessionid来匹配请求的数据,然后把数据和sessionid响应给浏览器,浏览器把sessionid储存在cookie中当浏览器第二次发送请求时,会把cookie中的sessionid放在请求头中,服务器拿到session后,和保存在服务器中的sessionid对比,找到相匹配的数据,响应给浏览器]]></content>
      <categories>
        <category>浏览器机制</category>
      </categories>
      <tags>
        <tag>web储存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回流与重绘]]></title>
    <url>%2F2017%2F02%2F13%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%2F</url>
    <content type="text"><![CDATA[浏览器解析渲染的步骤1.浏览器解析html,生成DOM树 2.解析css,生成样式结构体 3.DOM树和样式结构体结合,构建渲染树 4.先布局 5.再渲染 回流重新布局 发生在第4阶段--布局阶段 触发回流: 影响到布局属性改变(盒子大小宽高,margin等) 重绘重新绘制渲染 发生在第5阶段--渲染阶段 触发重绘: 只要回流,必重绘 只更改样式,没改变布局,只会重绘,不会回流 每个页面至少会触发一次回流与重绘浏览器会自动优化,将引起回流和重绘的操作,放到一个队列中,当到达一定的数量或间隔一定的时间,会对回流和重绘的操作进行批处理,这样就减少了回流和重绘的操作,提升了浏览器的性能获取性操作会打乱队列,为保证获取的准确性 所以当提及性能优化时,尽可能的减少回流与重绘的次数 1.尽量不要在for循环里进行获取性操作(会打乱浏览器自动优化) 2.直接使用className,少用style设置样式(className可以多个DOM公用) 3.display:none 离线处理(隐藏的元素不会出现在渲染树中,所以回流与重绘不会触发,只有显示隐藏的时候才会触发) 4.定位 脱标只会触发自己的回流与重绘,不会对标准流造成影响每优化一次回流与重绘,可提升15ms页面加载速度]]></content>
      <categories>
        <category>浏览器机制</category>
      </categories>
      <tags>
        <tag>浏览器机制</tag>
      </tags>
  </entry>
</search>
